<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Warehouse Wars Single Player</title>
    <style>
        body {
            font-family: sans-serif;
            background: black;
            color: white;
        }
        #game { margin: auto; }
        #game td { padding: 0; }
        #game img { width: 20px; height: 20px; }
        #controls img { width: 50px; height: 50px; cursor: pointer; }
    </style>
</head>
<body>
<h1 align="center">Warehouse Wars - Single Player Demo</h1>
<div id="stage"></div>
<div id="controls" align="center">
    <img src="icons/Controls/north.png" id="u">
    <br>
    <img src="icons/Controls/west.png" id="l">
    <img src="icons/player2.jpg" id="playerIcon">
    <img src="icons/Controls/east.png" id="r">
    <br>
    <img src="icons/Controls/south.png" id="d">
</div>
<script>
// Larger play field for a more interesting demo
const SIZE = 20;
const NUM_MONSTERS = 2;
// 35% of open cells will contain movable boxes
const BOX_RATIO = 0.35;
const TICK_MS = 500;

class Actor {
    constructor(x, y, stage) {
        this.x = x;
        this.y = y;
        this.stage = stage;
        this.dead = false;
    }
    getCoords() { return [this.x, this.y]; }
    setCoords(x, y) { this.x = x; this.y = y; }
    step() {}
}

class Player extends Actor {
    move(dx, dy) {
        const nx = this.x + dx;
        const ny = this.y + dy;
        const target = this.stage.grid[ny] && this.stage.grid[ny][nx];
        if (!target) {
            if (this.stage.isOpen(nx, ny)) this.stage.moveActor(this, nx, ny);
        } else if (target instanceof Box && target.movable) {
            if (this.stage.pushBox(target, dx, dy)) {
                this.stage.moveActor(this, nx, ny);
            }
        }
    }
}

class Monster extends Actor {
    step() {
        const dx = Math.floor(Math.random()*3) - 1;
        const dy = Math.floor(Math.random()*3) - 1;
        const nx = this.x + dx;
        const ny = this.y + dy;
        if (this.stage.player && nx === this.stage.player.x && ny === this.stage.player.y) {
            alert('You were caught!');
            window.location.reload();
            return;
        }
        if (this.stage.isOpen(nx, ny)) {
            this.stage.moveActor(this, nx, ny);
        }
    }
}

class Box extends Actor {
    constructor(x, y, stage, movable = true) {
        super(x, y, stage);
        this.movable = movable;
    }
}

class Stage {
    constructor(size) {
        this.size = size;
        this.grid = [];
        for (let y=0; y<size; y++) {
            const row = [];
            for (let x=0; x<size; x++) row.push(null);
            this.grid.push(row);
        }
        this.player = null;
        this.actors = [];
    }
    withinBounds(x, y) {
        return x >= 0 && x < this.size && y >= 0 && y < this.size;
    }
    isOpen(x, y) {
        return this.withinBounds(x, y) && !this.grid[y][x];
    }
    addActor(actor) {
        this.grid[actor.y][actor.x] = actor;
        this.actors.push(actor);
    }
    moveActor(actor, nx, ny) {
        this.grid[actor.y][actor.x] = null;
        actor.setCoords(nx, ny);
        this.grid[ny][nx] = actor;
    }
    pushBox(box, dx, dy) {
        const nx = box.x + dx;
        const ny = box.y + dy;
        if (!this.withinBounds(nx, ny)) return false;
        const target = this.grid[ny][nx];
        if (target) {
            if (target instanceof Box && target.movable && this.pushBox(target, dx, dy)) {
                this.moveActor(box, nx, ny);
                return true;
            }
            return false;
        }
        this.moveActor(box, nx, ny);
        return true;
    }
    removeActor(actor) {
        this.grid[actor.y][actor.x] = null;
        actor.dead = true;
        const idx = this.actors.indexOf(actor);
        if (idx >= 0) this.actors.splice(idx, 1);
    }
    monsterTrapped(monster) {
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx, dy] of dirs) {
            const nx = monster.x + dx;
            const ny = monster.y + dy;
            if (!this.withinBounds(nx, ny)) return false;
            const obj = this.grid[ny][nx];
            if (!(obj instanceof Box)) return false;
        }
        return true;
    }
    step() {
        for (const a of this.actors) {
            if (a instanceof Monster) a.step();
        }
        for (const a of [...this.actors]) {
            if (a instanceof Monster && this.monsterTrapped(a)) {
                this.removeActor(a);
            }
        }
    }
}

const stage = new Stage(SIZE);
function init() {
    const p = new Player(Math.floor(SIZE/2), Math.floor(SIZE/2), stage);
    stage.player = p;
    stage.addActor(p);
    // place immovable perimeter boxes
    for (let x=0; x<SIZE; x++) {
        stage.addActor(new Box(x, 0, stage, false));
        stage.addActor(new Box(x, SIZE-1, stage, false));
    }
    for (let y=1; y<SIZE-1; y++) {
        stage.addActor(new Box(0, y, stage, false));
        stage.addActor(new Box(SIZE-1, y, stage, false));
    }
    for (let i=0;i<NUM_MONSTERS;i++) {
        let x,y;
        do {
            x = Math.floor(Math.random()*SIZE);
            y = Math.floor(Math.random()*SIZE);
        } while(!stage.isOpen(x,y));
        stage.addActor(new Monster(x,y,stage));
    }
    const totalOpen = SIZE*SIZE - stage.actors.length;
    const numBoxes = Math.floor(totalOpen * BOX_RATIO);
    for (let i=0;i<numBoxes;i++) {
        let x,y;
        do {
            x = Math.floor(Math.random()*SIZE);
            y = Math.floor(Math.random()*SIZE);
        } while(!stage.isOpen(x,y));
        stage.addActor(new Box(x,y,stage,true));
    }
    draw();
    document.getElementById('u').onclick = ()=>move(0,-1);
    document.getElementById('d').onclick = ()=>move(0,1);
    document.getElementById('l').onclick = ()=>move(-1,0);
    document.getElementById('r').onclick = ()=>move(1,0);
    document.onkeydown = (e)=>{
        switch(e.key){
            case 'w': move(0,-1); break;
            case 's': move(0,1); break;
            case 'a': move(-1,0); break;
            case 'd': move(1,0); break;
        }
    };
    setInterval(()=>{ stage.step(); draw(); }, TICK_MS);
}

function move(dx, dy){
    stage.player.move(dx, dy);
    draw();
}

function draw(){
    const t = document.createElement('table');
    t.id = 'game';
    for(let y=0;y<SIZE;y++){
        const tr = document.createElement('tr');
        for(let x=0;x<SIZE;x++){
            const td = document.createElement('td');
            const cell = stage.grid[y][x];
            const img = document.createElement('img');
            if (cell instanceof Player) img.src = 'icons/player.jpg';
            else if (cell instanceof Monster) img.src = 'icons/Monsters/monster.png';
            else if (cell instanceof Box) img.src = cell.movable ? 'icons/Boxes/box.png' : 'icons/Boxes/wall.png';
            else img.src = 'icons/blank.png';
            td.appendChild(img);
            tr.appendChild(td);
        }
        t.appendChild(tr);
    }
    const stageDiv = document.getElementById('stage');
    stageDiv.innerHTML = '';
    stageDiv.appendChild(t);
}

init();
</script>
</body>
</html>
